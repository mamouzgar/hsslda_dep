---
title: "hsslda-intro"
author: "meelad amouzgar"
date: "7/5/2021"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hsslda-intro}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

Install and load the hsslda library:

You can install hsslda using:

```{r eval=FALSE}
remotes::install_github("mamouzgar/hsslda")
```



```{r, warning=FALSE, include=FALSE}
library(magrittr)
```

```{r, warning=FALSE, include=TRUE}
library(hsslda)
```


```{r, echo=TRUE, results = 'hide'}
Tcell_intro = read.csv("~/phd-projects/Rpackage/hsslda/data/TcellHartmann2020_sampleData.txt",sep="\t", stringsAsFactors = T)
```


```{r}
head(Tcell_intro)
colnames(Tcell_intro)
```

You can run hybrid subset selection on a dataset using runHSS(). 
runHSS takes as input a dataframe of cells (rows) and markers/genes (columns), and a vector of your class labels of interest. 
Here we will run HSS using the default, euclidean distance scoring method.
Note that some scoring metrics like silhouette or pixel class entropy (PCE) score will require additional packages.
```{r, echo=TRUE, results = 'hide'}
channels = c('GLUT1', 'HK2', 'GAPDH', 'LDHA', 'MCT1', 'PFKFB4', 'IDH2', 'CyclinB1', 'GLUD12', 'CS', 'OGDH', 'CytC', 'ATP5A', 'S6_p', 'HIF1A')
train.x = Tcell_intro[channels]
train.y = Tcell_intro[['labels']]
hss.result = runHSS(x = train.x, y = train.y, score.method = 'euclidean')

```


The hss.result object contains a few features:

You can visualize the elbow plot, which is ggplot configurable
```{r}
hss.result$ElbowPlot
```

The final output object contains a merged dataframe of your markers, class labels, and newly generated LD axes
```{r}
lda.df = hss.result$`HSS-LDA-result`
head(lda.df)
```

```{r, echo=FALSE}
lda.df$labels = train.y
```

```{r, echo=FALSE}
ggplot2::ggplot(lda.df,ggplot2::aes(x = LD1, y = LD2, color = labels)) +
  ggplot2::geom_point() +
  viridis::scale_color_viridis(discrete = TRUE, option = "viridis") 
```

The final HSS-LDA model is also saved
```{r, echo=TRUE}
hss.result$`HSS-LDA-model`
```

```{r, echo=FALSE, results = 'hide'}
newdata = train.x
```

You can use this final model to apply the same dimensionality reduction to new data using makeAxes.
```{r, echo=TRUE, results = 'hide'}
lda.df.newData = makeAxes(df = newdata, co =hss.result$`HSS-LDA-model`$scaling)
```


You can also add your own custom separation metric to perform feature selection with by changing score.method = 'custom' and adding custom function. 
The custom function must take in as input:

x dataframe of training data

y vector of class labels matching training data rows

cols vector of column names


```{r eval=FALSE}
hss.resultCustom = runHSS(x = train.x, y = train.y, score.method = 'custom', custom.score.method = myCustomFunction)
```


And that's how you use LDA with Hybrid Subset Selection!











